"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getObservatoryWsUri = exports.startIOSSession = void 0;
// @ts-ignore
const appium_ios_device_1 = require("appium-ios-device");
const appium_xcuitest_driver_1 = __importDefault(require("appium-xcuitest-driver"));
const net_1 = __importDefault(require("net"));
const logger_1 = require("../logger");
const observatory_1 = require("./observatory");
const setupNewIOSDriver = async (caps) => {
    const iosArgs = {
        javascriptEnabled: true,
    };
    const iosdriver = new appium_xcuitest_driver_1.default(iosArgs);
    const capsCopy = Object.assign({}, caps, { newCommandTimeout: 0 });
    await iosdriver.createSession(capsCopy);
    return iosdriver;
};
exports.startIOSSession = async (caps) => {
    logger_1.log.info(`Starting an IOS proxy session`);
    const iosdriver = await setupNewIOSDriver(caps);
    const observatoryWsUri = await exports.getObservatoryWsUri(iosdriver);
    return Promise.all([
        iosdriver,
        observatory_1.connectSocket(observatoryWsUri, caps.retryBackoffTime, caps.maxRetryCount),
    ]);
};
exports.getObservatoryWsUri = async (proxydriver) => {
    const urlObject = observatory_1.processLogToGetobservatory(proxydriver.logs.syslog.logs);
    const { udid } = proxydriver.opts;
    if (proxydriver.isRealDevice()) {
        logger_1.log.info(`Running on iOS real device`);
        const localServer = net_1.default.createServer(async (localSocket) => {
            let remoteSocket;
            try {
                remoteSocket = await appium_ios_device_1.utilities.connectPort(udid, urlObject.port);
            }
            catch (e) {
                localSocket.destroy();
                return;
            }
            const destroyCommChannel = () => {
                remoteSocket.unpipe(localSocket);
                localSocket.unpipe(remoteSocket);
            };
            remoteSocket.once(`close`, () => {
                destroyCommChannel();
                localSocket.destroy();
            });
            localSocket.once(`end`, destroyCommChannel);
            localSocket.once(`close`, () => {
                destroyCommChannel();
                remoteSocket.destroy();
            });
            localSocket.pipe(remoteSocket);
            remoteSocket.pipe(localSocket);
        });
        localServer.listen(urlObject.port);
        logger_1.log.info(`Port forwarding to: ${urlObject.port}`);
    }
    else {
        logger_1.log.info(`Running on iOS simulator`);
    }
    return urlObject.toJSON();
};
//# sourceMappingURL=ios.js.map